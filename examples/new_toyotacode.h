/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 32.20.1 Sun Oct 27 00:35:50 2019.
 */

#ifndef NEW_TOYOTACODE_H
#define NEW_TOYOTACODE_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define NEW_TOYOTACODE_KINEMATICS_FRAME_ID (0x24u)
#define NEW_TOYOTACODE_STEER_ANGLE_SENSOR_FRAME_ID (0x25u)
#define NEW_TOYOTACODE_BRAKE_FRAME_ID (0xa6u)
#define NEW_TOYOTACODE_WHEEL_SPEEDS_FRAME_ID (0xaau)
#define NEW_TOYOTACODE_SPEED_FRAME_ID (0xb4u)
#define NEW_TOYOTACODE_UKNOWN186_FRAME_ID (0xbau)
#define NEW_TOYOTACODE_UKNOWN291_FRAME_ID (0x123u)
#define NEW_TOYOTACODE_UKNOWN296_FRAME_ID (0x128u)
#define NEW_TOYOTACODE_DSU_SPEED_FRAME_ID (0x161u)
#define NEW_TOYOTACODE_STEERING_IPAS_COMMA_FRAME_ID (0x167u)
#define NEW_TOYOTACODE_TRACK_A_0_FRAME_ID (0x180u)
#define NEW_TOYOTACODE_TRACK_A_1_FRAME_ID (0x181u)
#define NEW_TOYOTACODE_TRACK_A_2_FRAME_ID (0x182u)
#define NEW_TOYOTACODE_TRACK_A_3_FRAME_ID (0x183u)
#define NEW_TOYOTACODE_TRACK_A_4_FRAME_ID (0x184u)
#define NEW_TOYOTACODE_TRACK_A_5_FRAME_ID (0x185u)
#define NEW_TOYOTACODE_TRACK_A_6_FRAME_ID (0x186u)
#define NEW_TOYOTACODE_TRACK_A_7_FRAME_ID (0x187u)
#define NEW_TOYOTACODE_TRACK_A_8_FRAME_ID (0x188u)
#define NEW_TOYOTACODE_TRACK_A_9_FRAME_ID (0x189u)
#define NEW_TOYOTACODE_TRACK_A_10_FRAME_ID (0x18au)
#define NEW_TOYOTACODE_TRACK_A_11_FRAME_ID (0x18bu)
#define NEW_TOYOTACODE_TRACK_A_12_FRAME_ID (0x18cu)
#define NEW_TOYOTACODE_TRACK_A_13_FRAME_ID (0x18du)
#define NEW_TOYOTACODE_TRACK_A_14_FRAME_ID (0x18eu)
#define NEW_TOYOTACODE_TRACK_A_15_FRAME_ID (0x18fu)
#define NEW_TOYOTACODE_TRACK_B_0_FRAME_ID (0x190u)
#define NEW_TOYOTACODE_TRACK_B_1_FRAME_ID (0x191u)
#define NEW_TOYOTACODE_TRACK_B_2_FRAME_ID (0x192u)
#define NEW_TOYOTACODE_TRACK_B_3_FRAME_ID (0x193u)
#define NEW_TOYOTACODE_TRACK_B_4_FRAME_ID (0x194u)
#define NEW_TOYOTACODE_TRACK_B_5_FRAME_ID (0x195u)
#define NEW_TOYOTACODE_TRACK_B_6_FRAME_ID (0x196u)
#define NEW_TOYOTACODE_TRACK_B_7_FRAME_ID (0x197u)
#define NEW_TOYOTACODE_TRACK_B_8_FRAME_ID (0x198u)
#define NEW_TOYOTACODE_TRACK_B_9_FRAME_ID (0x199u)
#define NEW_TOYOTACODE_TRACK_B_10_FRAME_ID (0x19au)
#define NEW_TOYOTACODE_TRACK_B_11_FRAME_ID (0x19bu)
#define NEW_TOYOTACODE_TRACK_B_12_FRAME_ID (0x19cu)
#define NEW_TOYOTACODE_TRACK_B_13_FRAME_ID (0x19du)
#define NEW_TOYOTACODE_TRACK_B_14_FRAME_ID (0x19eu)
#define NEW_TOYOTACODE_TRACK_B_15_FRAME_ID (0x19fu)
#define NEW_TOYOTACODE_NEW_MSG_1_FRAME_ID (0x240u)
#define NEW_TOYOTACODE_NEW_MSG_2_FRAME_ID (0x241u)
#define NEW_TOYOTACODE_PCM_CRUISE_FRAME_ID (0x1d2u)
#define NEW_TOYOTACODE_PCM_CRUISE_2_FRAME_ID (0x1d3u)
#define NEW_TOYOTACODE_GAS_COMMAND_FRAME_ID (0x200u)
#define NEW_TOYOTACODE_GAS_SENSOR_FRAME_ID (0x201u)
#define NEW_TOYOTACODE_BRAKE_MODULE_FRAME_ID (0x226u)
#define NEW_TOYOTACODE_ACCELEROMETER_FRAME_ID (0x228u)
#define NEW_TOYOTACODE_BRAKE_MODULE2_FRAME_ID (0x230u)
#define NEW_TOYOTACODE_GAS_PEDAL_FRAME_ID (0x245u)
#define NEW_TOYOTACODE_STEER_TORQUE_SENSOR_FRAME_ID (0x260u)
#define NEW_TOYOTACODE_EPS_STATUS_FRAME_ID (0x262u)
#define NEW_TOYOTACODE_STEERING_IPAS_FRAME_ID (0x266u)
#define NEW_TOYOTACODE_PRE_COLLISION_FRAME_ID (0x283u)
#define NEW_TOYOTACODE_STEERING_LKA_FRAME_ID (0x2e4u)
#define NEW_TOYOTACODE_LEAD_INFO_FRAME_ID (0x2e6u)
#define NEW_TOYOTACODE_ACC_CONTROL_FRAME_ID (0x343u)
#define NEW_TOYOTACODE_PCM_CRUISE_SM_FRAME_ID (0x399u)
#define NEW_TOYOTACODE_ESP_CONTROL_FRAME_ID (0x3b7u)
#define NEW_TOYOTACODE_ACC_HUD_FRAME_ID (0x411u)
#define NEW_TOYOTACODE_LKAS_HUD_FRAME_ID (0x412u)
#define NEW_TOYOTACODE_UI_SEETING_FRAME_ID (0x611u)
#define NEW_TOYOTACODE_STEERING_LEVERS_FRAME_ID (0x614u)
#define NEW_TOYOTACODE_SEATS_DOORS_FRAME_ID (0x620u)
#define NEW_TOYOTACODE_LIGHT_STALK_FRAME_ID (0x622u)
#define NEW_TOYOTACODE_RSA1_FRAME_ID (0x489u)
#define NEW_TOYOTACODE_RSA2_FRAME_ID (0x48au)
#define NEW_TOYOTACODE_RSA3_FRAME_ID (0x48bu)

/* Frame lengths in bytes. */
#define NEW_TOYOTACODE_KINEMATICS_LENGTH (8u)
#define NEW_TOYOTACODE_STEER_ANGLE_SENSOR_LENGTH (8u)
#define NEW_TOYOTACODE_BRAKE_LENGTH (8u)
#define NEW_TOYOTACODE_WHEEL_SPEEDS_LENGTH (8u)
#define NEW_TOYOTACODE_SPEED_LENGTH (8u)
#define NEW_TOYOTACODE_UKNOWN186_LENGTH (4u)
#define NEW_TOYOTACODE_UKNOWN291_LENGTH (7u)
#define NEW_TOYOTACODE_UKNOWN296_LENGTH (6u)
#define NEW_TOYOTACODE_DSU_SPEED_LENGTH (8u)
#define NEW_TOYOTACODE_STEERING_IPAS_COMMA_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_0_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_1_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_2_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_3_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_4_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_5_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_6_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_7_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_8_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_9_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_10_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_11_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_12_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_13_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_14_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_A_15_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_0_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_1_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_2_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_3_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_4_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_5_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_6_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_7_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_8_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_9_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_10_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_11_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_12_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_13_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_14_LENGTH (8u)
#define NEW_TOYOTACODE_TRACK_B_15_LENGTH (8u)
#define NEW_TOYOTACODE_NEW_MSG_1_LENGTH (8u)
#define NEW_TOYOTACODE_NEW_MSG_2_LENGTH (8u)
#define NEW_TOYOTACODE_PCM_CRUISE_LENGTH (8u)
#define NEW_TOYOTACODE_PCM_CRUISE_2_LENGTH (8u)
#define NEW_TOYOTACODE_GAS_COMMAND_LENGTH (6u)
#define NEW_TOYOTACODE_GAS_SENSOR_LENGTH (6u)
#define NEW_TOYOTACODE_BRAKE_MODULE_LENGTH (8u)
#define NEW_TOYOTACODE_ACCELEROMETER_LENGTH (8u)
#define NEW_TOYOTACODE_BRAKE_MODULE2_LENGTH (7u)
#define NEW_TOYOTACODE_GAS_PEDAL_LENGTH (8u)
#define NEW_TOYOTACODE_STEER_TORQUE_SENSOR_LENGTH (8u)
#define NEW_TOYOTACODE_EPS_STATUS_LENGTH (8u)
#define NEW_TOYOTACODE_STEERING_IPAS_LENGTH (8u)
#define NEW_TOYOTACODE_PRE_COLLISION_LENGTH (8u)
#define NEW_TOYOTACODE_STEERING_LKA_LENGTH (5u)
#define NEW_TOYOTACODE_LEAD_INFO_LENGTH (8u)
#define NEW_TOYOTACODE_ACC_CONTROL_LENGTH (8u)
#define NEW_TOYOTACODE_PCM_CRUISE_SM_LENGTH (8u)
#define NEW_TOYOTACODE_ESP_CONTROL_LENGTH (8u)
#define NEW_TOYOTACODE_ACC_HUD_LENGTH (8u)
#define NEW_TOYOTACODE_LKAS_HUD_LENGTH (8u)
#define NEW_TOYOTACODE_UI_SEETING_LENGTH (8u)
#define NEW_TOYOTACODE_STEERING_LEVERS_LENGTH (8u)
#define NEW_TOYOTACODE_SEATS_DOORS_LENGTH (8u)
#define NEW_TOYOTACODE_LIGHT_STALK_LENGTH (8u)
#define NEW_TOYOTACODE_RSA1_LENGTH (8u)
#define NEW_TOYOTACODE_RSA2_LENGTH (8u)
#define NEW_TOYOTACODE_RSA3_LENGTH (8u)

/* Extended or standard frame types. */
#define NEW_TOYOTACODE_KINEMATICS_IS_EXTENDED (0)
#define NEW_TOYOTACODE_STEER_ANGLE_SENSOR_IS_EXTENDED (0)
#define NEW_TOYOTACODE_BRAKE_IS_EXTENDED (0)
#define NEW_TOYOTACODE_WHEEL_SPEEDS_IS_EXTENDED (0)
#define NEW_TOYOTACODE_SPEED_IS_EXTENDED (0)
#define NEW_TOYOTACODE_UKNOWN186_IS_EXTENDED (0)
#define NEW_TOYOTACODE_UKNOWN291_IS_EXTENDED (0)
#define NEW_TOYOTACODE_UKNOWN296_IS_EXTENDED (0)
#define NEW_TOYOTACODE_DSU_SPEED_IS_EXTENDED (0)
#define NEW_TOYOTACODE_STEERING_IPAS_COMMA_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_0_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_1_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_2_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_3_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_4_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_5_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_6_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_7_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_8_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_9_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_10_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_11_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_12_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_13_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_14_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_A_15_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_0_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_1_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_2_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_3_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_4_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_5_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_6_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_7_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_8_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_9_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_10_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_11_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_12_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_13_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_14_IS_EXTENDED (0)
#define NEW_TOYOTACODE_TRACK_B_15_IS_EXTENDED (0)
#define NEW_TOYOTACODE_NEW_MSG_1_IS_EXTENDED (0)
#define NEW_TOYOTACODE_NEW_MSG_2_IS_EXTENDED (0)
#define NEW_TOYOTACODE_PCM_CRUISE_IS_EXTENDED (0)
#define NEW_TOYOTACODE_PCM_CRUISE_2_IS_EXTENDED (0)
#define NEW_TOYOTACODE_GAS_COMMAND_IS_EXTENDED (0)
#define NEW_TOYOTACODE_GAS_SENSOR_IS_EXTENDED (0)
#define NEW_TOYOTACODE_BRAKE_MODULE_IS_EXTENDED (0)
#define NEW_TOYOTACODE_ACCELEROMETER_IS_EXTENDED (0)
#define NEW_TOYOTACODE_BRAKE_MODULE2_IS_EXTENDED (0)
#define NEW_TOYOTACODE_GAS_PEDAL_IS_EXTENDED (0)
#define NEW_TOYOTACODE_STEER_TORQUE_SENSOR_IS_EXTENDED (0)
#define NEW_TOYOTACODE_EPS_STATUS_IS_EXTENDED (0)
#define NEW_TOYOTACODE_STEERING_IPAS_IS_EXTENDED (0)
#define NEW_TOYOTACODE_PRE_COLLISION_IS_EXTENDED (0)
#define NEW_TOYOTACODE_STEERING_LKA_IS_EXTENDED (0)
#define NEW_TOYOTACODE_LEAD_INFO_IS_EXTENDED (0)
#define NEW_TOYOTACODE_ACC_CONTROL_IS_EXTENDED (0)
#define NEW_TOYOTACODE_PCM_CRUISE_SM_IS_EXTENDED (0)
#define NEW_TOYOTACODE_ESP_CONTROL_IS_EXTENDED (0)
#define NEW_TOYOTACODE_ACC_HUD_IS_EXTENDED (0)
#define NEW_TOYOTACODE_LKAS_HUD_IS_EXTENDED (0)
#define NEW_TOYOTACODE_UI_SEETING_IS_EXTENDED (0)
#define NEW_TOYOTACODE_STEERING_LEVERS_IS_EXTENDED (0)
#define NEW_TOYOTACODE_SEATS_DOORS_IS_EXTENDED (0)
#define NEW_TOYOTACODE_LIGHT_STALK_IS_EXTENDED (0)
#define NEW_TOYOTACODE_RSA1_IS_EXTENDED (0)
#define NEW_TOYOTACODE_RSA2_IS_EXTENDED (0)
#define NEW_TOYOTACODE_RSA3_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define NEW_TOYOTACODE_PCM_CRUISE_CRUISE_STATE_OFF_CHOICE (1u)
#define NEW_TOYOTACODE_PCM_CRUISE_CRUISE_STATE_STANDSTILL_CHOICE (7u)
#define NEW_TOYOTACODE_PCM_CRUISE_CRUISE_STATE_ACTIVE_CHOICE (8u)

#define NEW_TOYOTACODE_PCM_CRUISE_2_LOW_SPEED_LOCKOUT_OK_CHOICE (1u)
#define NEW_TOYOTACODE_PCM_CRUISE_2_LOW_SPEED_LOCKOUT_LOW_SPEED_LOCKED_CHOICE (2u)

#define NEW_TOYOTACODE_GAS_SENSOR_STATE_NO_FAULT_CHOICE (0u)
#define NEW_TOYOTACODE_GAS_SENSOR_STATE_FAULT_BAD_CHECKSUM_CHOICE (1u)
#define NEW_TOYOTACODE_GAS_SENSOR_STATE_FAULT_SEND_CHOICE (2u)
#define NEW_TOYOTACODE_GAS_SENSOR_STATE_FAULT_SCE_CHOICE (3u)
#define NEW_TOYOTACODE_GAS_SENSOR_STATE_FAULT_STARTUP_CHOICE (4u)
#define NEW_TOYOTACODE_GAS_SENSOR_STATE_FAULT_TIMEOUT_CHOICE (5u)

#define NEW_TOYOTACODE_EPS_STATUS_IPAS_STATE_DISABLED_CHOICE (1u)
#define NEW_TOYOTACODE_EPS_STATUS_IPAS_STATE_ENABLED_CHOICE (3u)
#define NEW_TOYOTACODE_EPS_STATUS_IPAS_STATE_OVERRIDE_CHOICE (5u)

#define NEW_TOYOTACODE_EPS_STATUS_LKA_STATE_STANDBY_CHOICE (1u)
#define NEW_TOYOTACODE_EPS_STATUS_LKA_STATE_ACTIVE_CHOICE (5u)
#define NEW_TOYOTACODE_EPS_STATUS_LKA_STATE_TEMPORARY_FAULT2_CHOICE (9u)
#define NEW_TOYOTACODE_EPS_STATUS_LKA_STATE_TEMPORARY_FAULT_CHOICE (25u)

#define NEW_TOYOTACODE_STEERING_IPAS_STATE_DISABLED_CHOICE (1u)
#define NEW_TOYOTACODE_STEERING_IPAS_STATE_ENABLED_CHOICE (3u)

#define NEW_TOYOTACODE_STEERING_IPAS_DIRECTION_CMD_LEFT_CHOICE (1u)
#define NEW_TOYOTACODE_STEERING_IPAS_DIRECTION_CMD_CENTER_CHOICE (2u)
#define NEW_TOYOTACODE_STEERING_IPAS_DIRECTION_CMD_RIGHT_CHOICE (3u)

#define NEW_TOYOTACODE_PCM_CRUISE_SM_CRUISE_CONTROL_STATE_DISABLED_CHOICE (2u)
#define NEW_TOYOTACODE_PCM_CRUISE_SM_CRUISE_CONTROL_STATE_FAULTED_CHOICE (5u)
#define NEW_TOYOTACODE_PCM_CRUISE_SM_CRUISE_CONTROL_STATE_ENABLED_CHOICE (6u)
#define NEW_TOYOTACODE_PCM_CRUISE_SM_CRUISE_CONTROL_STATE_HOLD_WAITING_USER_CMD_CHOICE (10u)
#define NEW_TOYOTACODE_PCM_CRUISE_SM_CRUISE_CONTROL_STATE_HOLD_CHOICE (11u)

#define NEW_TOYOTACODE_LKAS_HUD_LEFT_LINE_NONE_CHOICE (0u)
#define NEW_TOYOTACODE_LKAS_HUD_LEFT_LINE_SOLID_CHOICE (1u)
#define NEW_TOYOTACODE_LKAS_HUD_LEFT_LINE_FADED_CHOICE (2u)
#define NEW_TOYOTACODE_LKAS_HUD_LEFT_LINE_ORANGE_CHOICE (3u)

#define NEW_TOYOTACODE_LKAS_HUD_RIGHT_LINE_NONE_CHOICE (0u)
#define NEW_TOYOTACODE_LKAS_HUD_RIGHT_LINE_SOLID_CHOICE (1u)
#define NEW_TOYOTACODE_LKAS_HUD_RIGHT_LINE_FADED_CHOICE (2u)
#define NEW_TOYOTACODE_LKAS_HUD_RIGHT_LINE_ORANGE_CHOICE (3u)

#define NEW_TOYOTACODE_LKAS_HUD_BARRIERS_NONE_CHOICE (0u)
#define NEW_TOYOTACODE_LKAS_HUD_BARRIERS_LEFT_CHOICE (1u)
#define NEW_TOYOTACODE_LKAS_HUD_BARRIERS_RIGHT_CHOICE (2u)
#define NEW_TOYOTACODE_LKAS_HUD_BARRIERS_BOTH_CHOICE (3u)

#define NEW_TOYOTACODE_LKAS_HUD_LDA_ALERT_NONE_CHOICE (0u)
#define NEW_TOYOTACODE_LKAS_HUD_LDA_ALERT_HOLD_CHOICE (1u)
#define NEW_TOYOTACODE_LKAS_HUD_LDA_ALERT_LDA_UNAVAILABLE_CHOICE (2u)
#define NEW_TOYOTACODE_LKAS_HUD_LDA_ALERT_HOLD_WITH_CONTINUOUS_BEEP_CHOICE (3u)

#define NEW_TOYOTACODE_UI_SEETING_UNITS_KM_CHOICE (1u)
#define NEW_TOYOTACODE_UI_SEETING_UNITS_MILES_CHOICE (2u)

#define NEW_TOYOTACODE_STEERING_LEVERS_TURN_SIGNALS_LEFT_CHOICE (1u)
#define NEW_TOYOTACODE_STEERING_LEVERS_TURN_SIGNALS_RIGHT_CHOICE (2u)
#define NEW_TOYOTACODE_STEERING_LEVERS_TURN_SIGNALS_NONE_CHOICE (3u)

#define NEW_TOYOTACODE_RSA1_TSGN1_NONE_CHOICE (0u)
#define NEW_TOYOTACODE_RSA1_TSGN1_SPEED_SIGN_CHOICE (1u)

#define NEW_TOYOTACODE_RSA1_SPLSGN2_NONE_CHOICE (0u)
#define NEW_TOYOTACODE_RSA1_SPLSGN2_WET_ROAD_CHOICE (4u)
#define NEW_TOYOTACODE_RSA1_SPLSGN2_RAIN_CHOICE (5u)
#define NEW_TOYOTACODE_RSA1_SPLSGN2_CONDITIONAL_BLANK_CHOICE (15u)

#define NEW_TOYOTACODE_RSA1_TSGN2_NONE_CHOICE (0u)
#define NEW_TOYOTACODE_RSA1_TSGN2_SPEED_SIGN_CHOICE (1u)

#define NEW_TOYOTACODE_RSA2_TSGN3_NONE_CHOICE (0u)
#define NEW_TOYOTACODE_RSA2_TSGN3_SPEED_SIGN_CHOICE (1u)
#define NEW_TOYOTACODE_RSA2_TSGN3_0_UNLIMITED_CHOICE (2u)
#define NEW_TOYOTACODE_RSA2_TSGN3_UNLIMITED_CHOICE (7u)
#define NEW_TOYOTACODE_RSA2_TSGN3_HIGHWAY_CHOICE (16u)
#define NEW_TOYOTACODE_RSA2_TSGN3_NO_HIGHWAY_CHOICE (17u)
#define NEW_TOYOTACODE_RSA2_TSGN3_MOTORWAY_CHOICE (18u)
#define NEW_TOYOTACODE_RSA2_TSGN3_NO_MOTORWAY_CHOICE (19u)
#define NEW_TOYOTACODE_RSA2_TSGN3_IN_CITY_CHOICE (20u)
#define NEW_TOYOTACODE_RSA2_TSGN3_OUTSIDE_CITY_CHOICE (21u)
#define NEW_TOYOTACODE_RSA2_TSGN3_PEDESTRIAN_AREA_CHOICE (22u)
#define NEW_TOYOTACODE_RSA2_TSGN3_NO_PEDESTRIAN_AREA_CHOICE (23u)
#define NEW_TOYOTACODE_RSA2_TSGN3_NO_OVERTAKING_LEFT_CHOICE (65u)
#define NEW_TOYOTACODE_RSA2_TSGN3_NO_OVERTAKING_RIGHT_CHOICE (66u)
#define NEW_TOYOTACODE_RSA2_TSGN3_OVERTAKING_ALLOWED_AGAIN_CHOICE (67u)
#define NEW_TOYOTACODE_RSA2_TSGN3_NO_ENTRY_CHOICE (129u)

#define NEW_TOYOTACODE_RSA2_SPLSGN3_NONE_CHOICE (0u)
#define NEW_TOYOTACODE_RSA2_SPLSGN3_WET_ROAD_CHOICE (4u)
#define NEW_TOYOTACODE_RSA2_SPLSGN3_RAIN_CHOICE (5u)
#define NEW_TOYOTACODE_RSA2_SPLSGN3_CONDITIONAL_BLANK_CHOICE (15u)

/**
 * Signals in message KINEMATICS.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_kinematics_t {
    /**
     * verify
     *
     * Range: 512..66047 (0..65535 -)
     * Scale: 1
     * Offset: -512
     */
    uint16_t yaw_rate;

    /**
     * does not seem the steer torque, tbd
     *
     * Range: 512..66047 (0..65535 -)
     * Scale: 1
     * Offset: -512
     */
    uint16_t steering_torque;

    /**
     * unit is tbd
     *
     * Range: 512..66047 (0..65535 -)
     * Scale: 1
     * Offset: -512
     */
    uint16_t accel_y;
};

/**
 * Signals in message STEER_ANGLE_SENSOR.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_steer_angle_sensor_t {
    /**
     * Range: -333.3333333333333333333333333..333.3333333333333333333333333 (-500..500 deg)
     * Scale: 1.5
     * Offset: 0
     */
    int16_t steer_angle;

    /**
     * 1/15th of the signal STEER_ANGLE, which is 1.5 deg; note that 0x8 is never set
     *
     * Range: -7..7 (-0.7..0.7 deg)
     * Scale: 0.1
     * Offset: 0
     */
    int8_t steer_fraction;

    /**
     * factor is tbd
     *
     * Range: -2000..2000 (-2000..2000 deg/s)
     * Scale: 1
     * Offset: 0
     */
    int16_t steer_rate;
};

/**
 * Signals in message BRAKE.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_brake_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_amount;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pedal;
};

/**
 * Signals in message WHEEL_SPEEDS.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_wheel_speeds_t {
    /**
     * Range: 6767..31767 (0..250 kph)
     * Scale: 0.01
     * Offset: -67.67
     */
    uint16_t wheel_speed_fr;

    /**
     * Range: 6767..31767 (0..250 kph)
     * Scale: 0.01
     * Offset: -67.67
     */
    uint16_t wheel_speed_fl;

    /**
     * Range: 6767..31767 (0..250 kph)
     * Scale: 0.01
     * Offset: -67.67
     */
    uint16_t wheel_speed_rr;

    /**
     * Range: 6767..31767 (0..250 kph)
     * Scale: 0.01
     * Offset: -67.67
     */
    uint16_t wheel_speed_rl;
};

/**
 * Signals in message SPEED.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_speed_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder;

    /**
     * Range: 0..25000 (0..250 kph)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t speed;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message UKNOWN186.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_uknown186_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t unknow186_1;
};

/**
 * Signals in message UKNOWN291.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_uknown291_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t unknown291_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t unknown291_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t unknown291_3;
};

/**
 * Signals in message UKNOWN296.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_uknown296_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t unknown296_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t unknown296_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t unknown296_3;
};

/**
 * Signals in message DSU_SPEED.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_dsu_speed_t {
    /**
     * Range: 7680..72960 (0..255 kph)
     * Scale: 0.00390625
     * Offset: -30
     */
    int16_t forward_speed;
};

/**
 * Signals in message STEERING_IPAS_COMMA.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_steering_ipas_comma_t {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state;

    /**
     * Range: -340..340 (-510..510 deg)
     * Scale: 1.5
     * Offset: 0
     */
    int16_t angle;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x10;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t direction_cmd;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x40;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x00;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_0.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_0_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_1.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_1_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_2.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_2_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_3.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_3_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_4.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_4_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_5.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_5_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_6.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_6_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_7.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_7_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_8.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_8_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_9.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_9_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_10.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_10_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_11.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_11_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_12.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_12_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_13.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_13_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_14.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_14_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_A_15.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_a_15_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..7500 (0..300 m)
     * Scale: 0.04
     * Offset: 0
     */
    uint16_t long_dist;

    /**
     * Range: -1250..1250 (-50..50 m)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t lat_dist;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_track;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t rel_speed;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t valid;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_0.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_0_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_1.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_1_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_2.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_2_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_3.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_3_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_4.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_4_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_5.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_5_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_6.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_6_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_7.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_7_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_8.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_8_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_9.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_9_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_10.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_10_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_11.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_11_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_12.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_12_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_13.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_13_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_14.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_14_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message TRACK_B_15.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_track_b_15_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: -64..63 (-64..63 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t rel_accel;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t score;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message NEW_MSG_1.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_new_msg_1_t {
    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;
};

/**
 * Signals in message NEW_MSG_2.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_new_msg_2_t {
    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t new_signal_2;
};

/**
 * Signals in message PCM_CRUISE.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_pcm_cruise_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_active;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gas_released;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t standstill_on;

    /**
     * net acceleration produced by the system, given ACCEL_CMD, road grade and other factors
     *
     * Range: -20000..20000 (-20..20 m/s2)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t accel_net;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_state;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message PCM_CRUISE_2.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_pcm_cruise_2_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t main_on;

    /**
     * in low speed lockout, system would always disengage below 28mph
     *
     * Range: 0..3 (0..3 kph)
     * Scale: 1
     * Offset: 0
     */
    uint8_t low_speed_lockout;

    /**
     * 43 kph are shown as 28mph, so conversion isnt perfect
     *
     * Range: 0..255 (0..255 kph)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_speed;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message GAS_COMMAND.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_gas_command_t {
    /**
     * Range: 474.0705882352941176470588235..480.3450980392156862745098039 (0..1 -)
     * Scale: 0.159375
     * Offset: -75.555
     */
    uint16_t gas_command;

    /**
     * Range: 948.1474509803921568627450980..954.4219607843137254901960784 (0..1 -)
     * Scale: 0.159375
     * Offset: -151.111
     */
    uint16_t gas_command2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter_pedal;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum_pedal;
};

/**
 * Signals in message GAS_SENSOR.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_gas_sensor_t {
    /**
     * Range: 474.0705882352941176470588235..480.3450980392156862745098039 (0..1 -)
     * Scale: 0.159375
     * Offset: -75.555
     */
    uint16_t interceptor_gas;

    /**
     * Range: 948.1474509803921568627450980..954.4219607843137254901960784 (0..1 -)
     * Scale: 0.159375
     * Offset: -151.111
     */
    uint16_t interceptor_gas2;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter_pedal;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum_pedal;
};

/**
 * Signals in message BRAKE_MODULE.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_brake_module_t {
    /**
     * seems prop to pedal force
     *
     * Range: 0..511 (0..511 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_pressure;

    /**
     * seems proportional to pedal displacement, unclear the max value of 0x1c8
     *
     * Range: 0..511 (0..511 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_position;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pressed;
};

/**
 * Signals in message ACCELEROMETER.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_accelerometer_t {
    /**
     * Range: -20000..20000 (-20..20 m/s2)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t accel_x;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t accel_z;
};

/**
 * Signals in message BRAKE_MODULE2.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_brake_module2_t {
    /**
     * another brake pressed?
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pressed;
};

/**
 * Signals in message GAS_PEDAL.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_gas_pedal_t {
    /**
     * it seems slightly filtered
     *
     * Range: 0..200 (0..1 -)
     * Scale: 0.005
     * Offset: 0
     */
    uint8_t gas_pedal;
};

/**
 * Signals in message STEER_TORQUE_SENSOR.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_steer_torque_sensor_t {
    /**
     * set when driver torque exceeds a certain value
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t steer_override;

    /**
     * driver torque
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t steer_torque_driver;

    /**
     * Range: -9046.499004885109462637959110..9046.499004885109462637959110 (-500..500 -)
     * Scale: 0.05527
     * Offset: 0
     */
    int16_t steer_angle;

    /**
     * Range: -30303.03030303030303030303030..30303.03030303030303030303030 (-20000..20000 -)
     * Scale: 0.66
     * Offset: 0
     */
    int16_t steer_torque_eps;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message EPS_STATUS.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_eps_status_t {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ipas_state;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lka_state;

    /**
     * seems 1 on Corolla, 0 on all others
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t type;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message STEERING_IPAS.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_steering_ipas_t {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state;

    /**
     * set to measured angle when ipas control isn't active
     *
     * Range: -340..340 (-510..510 deg)
     * Scale: 1.5
     * Offset: 0
     */
    int16_t angle;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x10;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t direction_cmd;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x40;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x00;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message PRE_COLLISION.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_pre_collision_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message STEERING_LKA.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_steering_lka_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_1;

    /**
     * Range: 0..63 (0..63 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t counter;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t steer_request;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t steer_torque_cmd;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lka_state;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message LEAD_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_lead_info_t {
    /**
     * Range: 0..6000 (0..300 m)
     * Scale: 0.05
     * Offset: 0
     */
    uint16_t lead_long_dist;

    /**
     * Range: -4000..4000 (-100..100 m/s)
     * Scale: 0.025
     * Offset: 0
     */
    int16_t lead_rel_speed;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message ACC_CONTROL.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_acc_control_t {
    /**
     * Range: -20000..20000 (-20..20 m/s2)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t accel_cmd;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x01;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mini_car;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t distance;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t release_standstill;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cancel_req;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t checksum;
};

/**
 * Signals in message PCM_CRUISE_SM.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_pcm_cruise_sm_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t main_on;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t distance_lines;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cruise_control_state;

    /**
     * set speed shown in UI with user set unit
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ui_set_speed;
};

/**
 * Signals in message ESP_CONTROL.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_esp_control_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tc_disabled;

    /**
     * brake lights when ACC commands decel
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_lights_acc;
};

/**
 * Signals in message ACC_HUD.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_acc_hud_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fcw;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x20;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x10;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x80;
};

/**
 * Signals in message LKAS_HUD.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_lkas_hud_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x01;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t left_line;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t right_line;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t barriers;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lda_malfunction;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t adjusting_camera;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t two_beeps;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x01_2;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lda_alert;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x0_c;

    /**
     * recommended for fcw and other important alerts
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t repeated_beeps;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x2_c;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x38;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_me_x02;
};

/**
 * Signals in message UI_SEETING.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_ui_seeting_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t units;
};

/**
 * Signals in message STEERING_LEVERS.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_steering_levers_t {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t turn_signals;
};

/**
 * Signals in message SEATS_DOORS.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_seats_doors_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t door_open_fl;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t door_open_fr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t door_open_rr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t door_open_rl;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t seatbelt_driver_unlatched;
};

/**
 * Signals in message LIGHT_STALK.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_light_stalk_t {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t auto_high_beam;
};

/**
 * Signals in message RSA1.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_rsa1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsgn1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsgngry1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsgnhlt1;

    /**
     * Numbers 0-199 is displayed, 200-254 displays circle without number and 255 is for no limit.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t spdval1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t splsgn1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t splsgn2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsgn2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsgngry2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsgnhlt2;

    /**
     * conditional speed value 70
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t spdval2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bzrrq_p;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bzrrq_a;

    /**
     * counter from 1 to f at 1 Hz
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t syncid1;
};

/**
 * Signals in message RSA2.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_rsa2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsgn3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsgngry3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsgnhlt3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t splsgn3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t splsgn4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsgn4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsgngry4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsgnhlt4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t dpsgnreq;

    /**
     * 1 if SPDVAL1 is set, otherwise 0
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sgnnump;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sgnnuma;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t spdunt;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsrwmsg;

    /**
     * counter from 1 to f at 1 Hz
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t syncid2;
};

/**
 * Signals in message RSA3.
 *
 * All signal values are as on the CAN bus.
 */
struct new_toyotacode_rsa3_t {
    /**
     * always 1
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsreqpd;

    /**
     * always 1
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsrmsw;

    /**
     * always 3
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t otsgnntm;

    /**
     * always 3
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ntlvlspd;

    /**
     * always 3
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ovspntm;

    /**
     * -5 at start then 2 after 2 seconds
     *
     * Range: -
     * Scale: 1
     * Offset: -5
     */
    uint8_t ovspvall;

    /**
     * -5 at start then 5 after 2 seconds
     *
     * Range: -
     * Scale: 1
     * Offset: -5
     */
    uint8_t ovspvalm;

    /**
     * -5 at start then 10 after 2 seconds
     *
     * Range: -
     * Scale: 1
     * Offset: -5
     */
    uint8_t ovspvalh;

    /**
     * always 1
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsrspu;
};

/**
 * Pack message KINEMATICS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_kinematics_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_kinematics_t *src_p,
    size_t size);

/**
 * Unpack message KINEMATICS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_kinematics_unpack(
    struct new_toyotacode_kinematics_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_kinematics_yaw_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_kinematics_yaw_rate_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_kinematics_yaw_rate_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_kinematics_steering_torque_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_kinematics_steering_torque_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_kinematics_steering_torque_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_kinematics_accel_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_kinematics_accel_y_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_kinematics_accel_y_is_in_range(uint16_t value);

/**
 * Pack message STEER_ANGLE_SENSOR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_steer_angle_sensor_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_steer_angle_sensor_t *src_p,
    size_t size);

/**
 * Unpack message STEER_ANGLE_SENSOR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_steer_angle_sensor_unpack(
    struct new_toyotacode_steer_angle_sensor_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_steer_angle_sensor_steer_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steer_angle_sensor_steer_angle_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steer_angle_sensor_steer_angle_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_steer_angle_sensor_steer_fraction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steer_angle_sensor_steer_fraction_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steer_angle_sensor_steer_fraction_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_steer_angle_sensor_steer_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steer_angle_sensor_steer_rate_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steer_angle_sensor_steer_rate_is_in_range(int16_t value);

/**
 * Pack message BRAKE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_brake_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_brake_t *src_p,
    size_t size);

/**
 * Unpack message BRAKE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_brake_unpack(
    struct new_toyotacode_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_brake_brake_amount_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_brake_brake_amount_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_brake_brake_amount_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_brake_brake_pedal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_brake_brake_pedal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_brake_brake_pedal_is_in_range(uint8_t value);

/**
 * Pack message WHEEL_SPEEDS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_wheel_speeds_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_wheel_speeds_t *src_p,
    size_t size);

/**
 * Unpack message WHEEL_SPEEDS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_wheel_speeds_unpack(
    struct new_toyotacode_wheel_speeds_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_wheel_speeds_wheel_speed_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_wheel_speeds_wheel_speed_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_wheel_speeds_wheel_speed_fr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_wheel_speeds_wheel_speed_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_wheel_speeds_wheel_speed_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_wheel_speeds_wheel_speed_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_wheel_speeds_wheel_speed_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_wheel_speeds_wheel_speed_rr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_wheel_speeds_wheel_speed_rr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_wheel_speeds_wheel_speed_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_wheel_speeds_wheel_speed_rl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_wheel_speeds_wheel_speed_rl_is_in_range(uint16_t value);

/**
 * Pack message SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_speed_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_speed_t *src_p,
    size_t size);

/**
 * Unpack message SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_speed_unpack(
    struct new_toyotacode_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_speed_encoder_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_speed_encoder_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_speed_encoder_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_speed_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_speed_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_speed_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_speed_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_speed_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_speed_checksum_is_in_range(uint8_t value);

/**
 * Pack message UKNOWN186.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_uknown186_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_uknown186_t *src_p,
    size_t size);

/**
 * Unpack message UKNOWN186.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_uknown186_unpack(
    struct new_toyotacode_uknown186_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t new_toyotacode_uknown186_unknow186_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_uknown186_unknow186_1_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_uknown186_unknow186_1_is_in_range(uint32_t value);

/**
 * Pack message UKNOWN291.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_uknown291_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_uknown291_t *src_p,
    size_t size);

/**
 * Unpack message UKNOWN291.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_uknown291_unpack(
    struct new_toyotacode_uknown291_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_uknown291_unknown291_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_uknown291_unknown291_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_uknown291_unknown291_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_uknown291_unknown291_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_uknown291_unknown291_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_uknown291_unknown291_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_uknown291_unknown291_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_uknown291_unknown291_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_uknown291_unknown291_3_is_in_range(uint8_t value);

/**
 * Pack message UKNOWN296.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_uknown296_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_uknown296_t *src_p,
    size_t size);

/**
 * Unpack message UKNOWN296.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_uknown296_unpack(
    struct new_toyotacode_uknown296_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_uknown296_unknown296_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_uknown296_unknown296_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_uknown296_unknown296_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_uknown296_unknown296_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_uknown296_unknown296_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_uknown296_unknown296_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_uknown296_unknown296_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_uknown296_unknown296_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_uknown296_unknown296_3_is_in_range(uint8_t value);

/**
 * Pack message DSU_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_dsu_speed_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_dsu_speed_t *src_p,
    size_t size);

/**
 * Unpack message DSU_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_dsu_speed_unpack(
    struct new_toyotacode_dsu_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_dsu_speed_forward_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_dsu_speed_forward_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_dsu_speed_forward_speed_is_in_range(int16_t value);

/**
 * Pack message STEERING_IPAS_COMMA.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_steering_ipas_comma_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_steering_ipas_comma_t *src_p,
    size_t size);

/**
 * Unpack message STEERING_IPAS_COMMA.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_steering_ipas_comma_unpack(
    struct new_toyotacode_steering_ipas_comma_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_ipas_comma_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_ipas_comma_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_ipas_comma_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_steering_ipas_comma_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_ipas_comma_angle_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_ipas_comma_angle_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_ipas_comma_set_me_x10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_ipas_comma_set_me_x10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_ipas_comma_set_me_x10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_ipas_comma_direction_cmd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_ipas_comma_direction_cmd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_ipas_comma_direction_cmd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_ipas_comma_set_me_x40_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_ipas_comma_set_me_x40_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_ipas_comma_set_me_x40_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_ipas_comma_set_me_x00_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_ipas_comma_set_me_x00_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_ipas_comma_set_me_x00_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_ipas_comma_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_ipas_comma_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_ipas_comma_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_0_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_0_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_0_unpack(
    struct new_toyotacode_track_a_0_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_0_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_0_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_0_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_0_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_0_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_0_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_0_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_0_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_0_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_0_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_0_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_0_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_0_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_0_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_0_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_0_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_0_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_0_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_0_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_0_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_0_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_1_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_1_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_1_unpack(
    struct new_toyotacode_track_a_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_1_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_1_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_1_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_1_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_1_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_1_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_1_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_1_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_1_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_1_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_1_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_1_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_1_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_1_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_1_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_1_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_1_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_1_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_1_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_1_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_1_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_2_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_2_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_2_unpack(
    struct new_toyotacode_track_a_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_2_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_2_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_2_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_2_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_2_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_2_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_2_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_2_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_2_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_2_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_2_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_2_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_2_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_2_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_2_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_2_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_2_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_2_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_2_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_2_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_2_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_3_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_3_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_3_unpack(
    struct new_toyotacode_track_a_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_3_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_3_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_3_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_3_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_3_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_3_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_3_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_3_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_3_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_3_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_3_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_3_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_3_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_3_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_3_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_3_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_3_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_3_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_3_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_3_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_3_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_4_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_4_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_4_unpack(
    struct new_toyotacode_track_a_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_4_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_4_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_4_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_4_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_4_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_4_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_4_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_4_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_4_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_4_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_4_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_4_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_4_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_4_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_4_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_4_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_4_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_4_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_4_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_4_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_4_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_5_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_5_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_5_unpack(
    struct new_toyotacode_track_a_5_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_5_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_5_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_5_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_5_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_5_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_5_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_5_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_5_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_5_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_5_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_5_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_5_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_5_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_5_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_5_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_5_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_5_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_5_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_5_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_5_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_5_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_6_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_6_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_6_unpack(
    struct new_toyotacode_track_a_6_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_6_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_6_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_6_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_6_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_6_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_6_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_6_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_6_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_6_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_6_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_6_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_6_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_6_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_6_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_6_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_6_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_6_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_6_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_6_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_6_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_6_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_7.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_7_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_7_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_7.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_7_unpack(
    struct new_toyotacode_track_a_7_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_7_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_7_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_7_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_7_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_7_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_7_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_7_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_7_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_7_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_7_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_7_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_7_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_7_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_7_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_7_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_7_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_7_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_7_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_7_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_7_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_7_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_8.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_8_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_8_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_8.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_8_unpack(
    struct new_toyotacode_track_a_8_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_8_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_8_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_8_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_8_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_8_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_8_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_8_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_8_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_8_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_8_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_8_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_8_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_8_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_8_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_8_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_8_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_8_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_8_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_8_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_8_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_8_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_9.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_9_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_9_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_9.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_9_unpack(
    struct new_toyotacode_track_a_9_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_9_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_9_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_9_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_9_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_9_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_9_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_9_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_9_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_9_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_9_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_9_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_9_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_9_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_9_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_9_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_9_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_9_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_9_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_9_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_9_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_9_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_10.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_10_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_10_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_10.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_10_unpack(
    struct new_toyotacode_track_a_10_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_10_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_10_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_10_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_10_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_10_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_10_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_10_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_10_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_10_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_10_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_10_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_10_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_10_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_10_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_10_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_10_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_10_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_10_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_10_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_10_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_10_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_11.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_11_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_11_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_11.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_11_unpack(
    struct new_toyotacode_track_a_11_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_11_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_11_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_11_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_11_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_11_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_11_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_11_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_11_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_11_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_11_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_11_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_11_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_11_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_11_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_11_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_11_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_11_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_11_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_11_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_11_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_11_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_12.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_12_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_12_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_12.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_12_unpack(
    struct new_toyotacode_track_a_12_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_12_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_12_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_12_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_12_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_12_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_12_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_12_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_12_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_12_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_12_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_12_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_12_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_12_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_12_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_12_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_12_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_12_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_12_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_12_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_12_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_12_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_13.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_13_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_13_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_13.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_13_unpack(
    struct new_toyotacode_track_a_13_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_13_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_13_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_13_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_13_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_13_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_13_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_13_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_13_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_13_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_13_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_13_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_13_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_13_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_13_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_13_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_13_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_13_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_13_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_13_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_13_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_13_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_14.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_14_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_14_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_14.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_14_unpack(
    struct new_toyotacode_track_a_14_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_14_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_14_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_14_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_14_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_14_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_14_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_14_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_14_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_14_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_14_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_14_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_14_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_14_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_14_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_14_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_14_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_14_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_14_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_14_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_14_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_14_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_A_15.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_a_15_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_a_15_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_A_15.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_a_15_unpack(
    struct new_toyotacode_track_a_15_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_15_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_15_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_15_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_track_a_15_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_15_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_15_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_15_lat_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_15_lat_dist_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_15_lat_dist_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_15_new_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_15_new_track_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_15_new_track_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_track_a_15_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_15_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_15_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_15_valid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_15_valid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_15_valid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_a_15_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_a_15_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_a_15_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_0_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_0_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_0_unpack(
    struct new_toyotacode_track_b_0_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_0_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_0_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_0_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_0_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_0_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_0_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_0_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_0_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_0_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_0_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_0_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_0_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_1_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_1_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_1_unpack(
    struct new_toyotacode_track_b_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_1_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_1_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_1_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_1_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_1_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_1_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_1_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_1_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_1_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_1_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_1_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_1_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_2_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_2_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_2_unpack(
    struct new_toyotacode_track_b_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_2_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_2_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_2_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_2_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_2_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_2_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_2_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_2_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_2_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_2_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_2_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_2_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_3_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_3_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_3_unpack(
    struct new_toyotacode_track_b_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_3_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_3_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_3_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_3_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_3_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_3_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_3_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_3_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_3_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_3_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_3_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_3_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_4.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_4_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_4_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_4.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_4_unpack(
    struct new_toyotacode_track_b_4_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_4_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_4_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_4_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_4_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_4_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_4_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_4_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_4_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_4_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_4_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_4_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_4_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_5_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_5_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_5_unpack(
    struct new_toyotacode_track_b_5_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_5_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_5_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_5_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_5_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_5_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_5_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_5_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_5_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_5_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_5_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_5_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_5_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_6_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_6_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_6_unpack(
    struct new_toyotacode_track_b_6_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_6_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_6_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_6_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_6_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_6_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_6_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_6_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_6_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_6_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_6_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_6_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_6_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_7.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_7_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_7_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_7.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_7_unpack(
    struct new_toyotacode_track_b_7_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_7_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_7_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_7_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_7_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_7_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_7_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_7_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_7_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_7_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_7_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_7_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_7_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_8.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_8_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_8_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_8.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_8_unpack(
    struct new_toyotacode_track_b_8_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_8_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_8_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_8_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_8_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_8_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_8_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_8_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_8_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_8_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_8_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_8_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_8_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_9.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_9_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_9_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_9.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_9_unpack(
    struct new_toyotacode_track_b_9_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_9_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_9_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_9_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_9_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_9_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_9_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_9_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_9_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_9_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_9_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_9_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_9_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_10.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_10_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_10_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_10.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_10_unpack(
    struct new_toyotacode_track_b_10_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_10_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_10_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_10_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_10_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_10_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_10_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_10_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_10_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_10_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_10_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_10_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_10_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_11.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_11_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_11_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_11.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_11_unpack(
    struct new_toyotacode_track_b_11_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_11_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_11_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_11_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_11_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_11_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_11_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_11_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_11_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_11_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_11_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_11_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_11_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_12.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_12_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_12_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_12.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_12_unpack(
    struct new_toyotacode_track_b_12_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_12_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_12_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_12_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_12_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_12_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_12_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_12_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_12_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_12_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_12_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_12_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_12_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_13.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_13_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_13_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_13.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_13_unpack(
    struct new_toyotacode_track_b_13_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_13_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_13_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_13_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_13_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_13_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_13_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_13_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_13_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_13_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_13_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_13_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_13_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_14.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_14_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_14_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_14.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_14_unpack(
    struct new_toyotacode_track_b_14_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_14_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_14_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_14_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_14_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_14_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_14_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_14_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_14_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_14_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_14_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_14_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_14_checksum_is_in_range(uint8_t value);

/**
 * Pack message TRACK_B_15.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_track_b_15_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_track_b_15_t *src_p,
    size_t size);

/**
 * Unpack message TRACK_B_15.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_track_b_15_unpack(
    struct new_toyotacode_track_b_15_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_15_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_15_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_15_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t new_toyotacode_track_b_15_rel_accel_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_15_rel_accel_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_15_rel_accel_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_15_score_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_15_score_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_15_score_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_track_b_15_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_track_b_15_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_track_b_15_checksum_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_new_msg_1_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_new_msg_1_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_new_msg_1_unpack(
    struct new_toyotacode_new_msg_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_new_msg_1_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_new_msg_1_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_new_msg_1_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_new_msg_1_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_new_msg_1_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_new_msg_1_new_signal_2_is_in_range(uint8_t value);

/**
 * Pack message NEW_MSG_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_new_msg_2_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_new_msg_2_t *src_p,
    size_t size);

/**
 * Unpack message NEW_MSG_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_new_msg_2_unpack(
    struct new_toyotacode_new_msg_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_new_msg_2_new_signal_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_new_msg_2_new_signal_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_new_msg_2_new_signal_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_new_msg_2_new_signal_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_new_msg_2_new_signal_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_new_msg_2_new_signal_2_is_in_range(uint8_t value);

/**
 * Pack message PCM_CRUISE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_pcm_cruise_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_pcm_cruise_t *src_p,
    size_t size);

/**
 * Unpack message PCM_CRUISE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_pcm_cruise_unpack(
    struct new_toyotacode_pcm_cruise_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_pcm_cruise_cruise_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_pcm_cruise_cruise_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_pcm_cruise_cruise_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_pcm_cruise_gas_released_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_pcm_cruise_gas_released_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_pcm_cruise_gas_released_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_pcm_cruise_standstill_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_pcm_cruise_standstill_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_pcm_cruise_standstill_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_pcm_cruise_accel_net_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_pcm_cruise_accel_net_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_pcm_cruise_accel_net_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_pcm_cruise_cruise_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_pcm_cruise_cruise_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_pcm_cruise_cruise_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_pcm_cruise_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_pcm_cruise_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_pcm_cruise_checksum_is_in_range(uint8_t value);

/**
 * Pack message PCM_CRUISE_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_pcm_cruise_2_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_pcm_cruise_2_t *src_p,
    size_t size);

/**
 * Unpack message PCM_CRUISE_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_pcm_cruise_2_unpack(
    struct new_toyotacode_pcm_cruise_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_pcm_cruise_2_main_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_pcm_cruise_2_main_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_pcm_cruise_2_main_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_pcm_cruise_2_low_speed_lockout_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_pcm_cruise_2_low_speed_lockout_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_pcm_cruise_2_low_speed_lockout_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_pcm_cruise_2_set_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_pcm_cruise_2_set_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_pcm_cruise_2_set_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_pcm_cruise_2_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_pcm_cruise_2_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_pcm_cruise_2_checksum_is_in_range(uint8_t value);

/**
 * Pack message GAS_COMMAND.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_gas_command_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_gas_command_t *src_p,
    size_t size);

/**
 * Unpack message GAS_COMMAND.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_gas_command_unpack(
    struct new_toyotacode_gas_command_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_gas_command_gas_command_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_gas_command_gas_command_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_gas_command_gas_command_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_gas_command_gas_command2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_gas_command_gas_command2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_gas_command_gas_command2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_gas_command_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_gas_command_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_gas_command_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_gas_command_counter_pedal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_gas_command_counter_pedal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_gas_command_counter_pedal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_gas_command_checksum_pedal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_gas_command_checksum_pedal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_gas_command_checksum_pedal_is_in_range(uint8_t value);

/**
 * Pack message GAS_SENSOR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_gas_sensor_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_gas_sensor_t *src_p,
    size_t size);

/**
 * Unpack message GAS_SENSOR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_gas_sensor_unpack(
    struct new_toyotacode_gas_sensor_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_gas_sensor_interceptor_gas_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_gas_sensor_interceptor_gas_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_gas_sensor_interceptor_gas_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_gas_sensor_interceptor_gas2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_gas_sensor_interceptor_gas2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_gas_sensor_interceptor_gas2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_gas_sensor_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_gas_sensor_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_gas_sensor_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_gas_sensor_counter_pedal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_gas_sensor_counter_pedal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_gas_sensor_counter_pedal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_gas_sensor_checksum_pedal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_gas_sensor_checksum_pedal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_gas_sensor_checksum_pedal_is_in_range(uint8_t value);

/**
 * Pack message BRAKE_MODULE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_brake_module_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_brake_module_t *src_p,
    size_t size);

/**
 * Unpack message BRAKE_MODULE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_brake_module_unpack(
    struct new_toyotacode_brake_module_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_brake_module_brake_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_brake_module_brake_pressure_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_brake_module_brake_pressure_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_brake_module_brake_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_brake_module_brake_position_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_brake_module_brake_position_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_brake_module_brake_pressed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_brake_module_brake_pressed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_brake_module_brake_pressed_is_in_range(uint8_t value);

/**
 * Pack message ACCELEROMETER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_accelerometer_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_accelerometer_t *src_p,
    size_t size);

/**
 * Unpack message ACCELEROMETER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_accelerometer_unpack(
    struct new_toyotacode_accelerometer_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_accelerometer_accel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_accelerometer_accel_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_accelerometer_accel_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_accelerometer_accel_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_accelerometer_accel_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_accelerometer_accel_z_is_in_range(int16_t value);

/**
 * Pack message BRAKE_MODULE2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_brake_module2_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_brake_module2_t *src_p,
    size_t size);

/**
 * Unpack message BRAKE_MODULE2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_brake_module2_unpack(
    struct new_toyotacode_brake_module2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_brake_module2_brake_pressed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_brake_module2_brake_pressed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_brake_module2_brake_pressed_is_in_range(uint8_t value);

/**
 * Pack message GAS_PEDAL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_gas_pedal_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_gas_pedal_t *src_p,
    size_t size);

/**
 * Unpack message GAS_PEDAL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_gas_pedal_unpack(
    struct new_toyotacode_gas_pedal_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_gas_pedal_gas_pedal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_gas_pedal_gas_pedal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_gas_pedal_gas_pedal_is_in_range(uint8_t value);

/**
 * Pack message STEER_TORQUE_SENSOR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_steer_torque_sensor_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_steer_torque_sensor_t *src_p,
    size_t size);

/**
 * Unpack message STEER_TORQUE_SENSOR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_steer_torque_sensor_unpack(
    struct new_toyotacode_steer_torque_sensor_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steer_torque_sensor_steer_override_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steer_torque_sensor_steer_override_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steer_torque_sensor_steer_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_steer_torque_sensor_steer_torque_driver_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steer_torque_sensor_steer_torque_driver_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steer_torque_sensor_steer_torque_driver_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_steer_torque_sensor_steer_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steer_torque_sensor_steer_angle_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steer_torque_sensor_steer_angle_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_steer_torque_sensor_steer_torque_eps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steer_torque_sensor_steer_torque_eps_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steer_torque_sensor_steer_torque_eps_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steer_torque_sensor_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steer_torque_sensor_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steer_torque_sensor_checksum_is_in_range(uint8_t value);

/**
 * Pack message EPS_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_eps_status_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_eps_status_t *src_p,
    size_t size);

/**
 * Unpack message EPS_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_eps_status_unpack(
    struct new_toyotacode_eps_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_eps_status_ipas_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_eps_status_ipas_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_eps_status_ipas_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_eps_status_lka_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_eps_status_lka_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_eps_status_lka_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_eps_status_type_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_eps_status_type_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_eps_status_type_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_eps_status_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_eps_status_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_eps_status_checksum_is_in_range(uint8_t value);

/**
 * Pack message STEERING_IPAS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_steering_ipas_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_steering_ipas_t *src_p,
    size_t size);

/**
 * Unpack message STEERING_IPAS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_steering_ipas_unpack(
    struct new_toyotacode_steering_ipas_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_ipas_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_ipas_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_ipas_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_steering_ipas_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_ipas_angle_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_ipas_angle_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_ipas_set_me_x10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_ipas_set_me_x10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_ipas_set_me_x10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_ipas_direction_cmd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_ipas_direction_cmd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_ipas_direction_cmd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_ipas_set_me_x40_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_ipas_set_me_x40_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_ipas_set_me_x40_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_ipas_set_me_x00_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_ipas_set_me_x00_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_ipas_set_me_x00_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_ipas_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_ipas_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_ipas_checksum_is_in_range(uint8_t value);

/**
 * Pack message PRE_COLLISION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_pre_collision_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_pre_collision_t *src_p,
    size_t size);

/**
 * Unpack message PRE_COLLISION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_pre_collision_unpack(
    struct new_toyotacode_pre_collision_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message STEERING_LKA.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_steering_lka_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_steering_lka_t *src_p,
    size_t size);

/**
 * Unpack message STEERING_LKA.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_steering_lka_unpack(
    struct new_toyotacode_steering_lka_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_lka_set_me_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_lka_set_me_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_lka_set_me_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_lka_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_lka_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_lka_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_lka_steer_request_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_lka_steer_request_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_lka_steer_request_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_steering_lka_steer_torque_cmd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_lka_steer_torque_cmd_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_lka_steer_torque_cmd_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_lka_lka_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_lka_lka_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_lka_lka_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_lka_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_lka_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_lka_checksum_is_in_range(uint8_t value);

/**
 * Pack message LEAD_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_lead_info_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_lead_info_t *src_p,
    size_t size);

/**
 * Unpack message LEAD_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_lead_info_unpack(
    struct new_toyotacode_lead_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t new_toyotacode_lead_info_lead_long_dist_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lead_info_lead_long_dist_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lead_info_lead_long_dist_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_lead_info_lead_rel_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lead_info_lead_rel_speed_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lead_info_lead_rel_speed_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lead_info_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lead_info_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lead_info_checksum_is_in_range(uint8_t value);

/**
 * Pack message ACC_CONTROL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_acc_control_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_acc_control_t *src_p,
    size_t size);

/**
 * Unpack message ACC_CONTROL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_acc_control_unpack(
    struct new_toyotacode_acc_control_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t new_toyotacode_acc_control_accel_cmd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_acc_control_accel_cmd_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_acc_control_accel_cmd_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_acc_control_set_me_x01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_acc_control_set_me_x01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_acc_control_set_me_x01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_acc_control_mini_car_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_acc_control_mini_car_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_acc_control_mini_car_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_acc_control_distance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_acc_control_distance_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_acc_control_distance_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_acc_control_set_me_x3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_acc_control_set_me_x3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_acc_control_set_me_x3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_acc_control_release_standstill_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_acc_control_release_standstill_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_acc_control_release_standstill_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_acc_control_set_me_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_acc_control_set_me_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_acc_control_set_me_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_acc_control_cancel_req_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_acc_control_cancel_req_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_acc_control_cancel_req_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_acc_control_checksum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_acc_control_checksum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_acc_control_checksum_is_in_range(uint8_t value);

/**
 * Pack message PCM_CRUISE_SM.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_pcm_cruise_sm_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_pcm_cruise_sm_t *src_p,
    size_t size);

/**
 * Unpack message PCM_CRUISE_SM.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_pcm_cruise_sm_unpack(
    struct new_toyotacode_pcm_cruise_sm_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_pcm_cruise_sm_main_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_pcm_cruise_sm_main_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_pcm_cruise_sm_main_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_pcm_cruise_sm_distance_lines_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_pcm_cruise_sm_distance_lines_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_pcm_cruise_sm_distance_lines_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_pcm_cruise_sm_cruise_control_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_pcm_cruise_sm_cruise_control_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_pcm_cruise_sm_cruise_control_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_pcm_cruise_sm_ui_set_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_pcm_cruise_sm_ui_set_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_pcm_cruise_sm_ui_set_speed_is_in_range(uint8_t value);

/**
 * Pack message ESP_CONTROL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_esp_control_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_esp_control_t *src_p,
    size_t size);

/**
 * Unpack message ESP_CONTROL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_esp_control_unpack(
    struct new_toyotacode_esp_control_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_esp_control_tc_disabled_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_esp_control_tc_disabled_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_esp_control_tc_disabled_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_esp_control_brake_lights_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_esp_control_brake_lights_acc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_esp_control_brake_lights_acc_is_in_range(uint8_t value);

/**
 * Pack message ACC_HUD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_acc_hud_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_acc_hud_t *src_p,
    size_t size);

/**
 * Unpack message ACC_HUD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_acc_hud_unpack(
    struct new_toyotacode_acc_hud_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_acc_hud_fcw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_acc_hud_fcw_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_acc_hud_fcw_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_acc_hud_set_me_x20_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_acc_hud_set_me_x20_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_acc_hud_set_me_x20_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_acc_hud_set_me_x10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_acc_hud_set_me_x10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_acc_hud_set_me_x10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_acc_hud_set_me_x80_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_acc_hud_set_me_x80_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_acc_hud_set_me_x80_is_in_range(uint8_t value);

/**
 * Pack message LKAS_HUD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_lkas_hud_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_lkas_hud_t *src_p,
    size_t size);

/**
 * Unpack message LKAS_HUD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_lkas_hud_unpack(
    struct new_toyotacode_lkas_hud_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lkas_hud_set_me_x01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lkas_hud_set_me_x01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lkas_hud_set_me_x01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lkas_hud_left_line_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lkas_hud_left_line_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lkas_hud_left_line_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lkas_hud_right_line_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lkas_hud_right_line_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lkas_hud_right_line_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lkas_hud_barriers_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lkas_hud_barriers_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lkas_hud_barriers_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lkas_hud_lda_malfunction_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lkas_hud_lda_malfunction_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lkas_hud_lda_malfunction_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lkas_hud_adjusting_camera_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lkas_hud_adjusting_camera_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lkas_hud_adjusting_camera_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lkas_hud_two_beeps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lkas_hud_two_beeps_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lkas_hud_two_beeps_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lkas_hud_set_me_x01_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lkas_hud_set_me_x01_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lkas_hud_set_me_x01_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lkas_hud_lda_alert_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lkas_hud_lda_alert_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lkas_hud_lda_alert_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lkas_hud_set_me_x0_c_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lkas_hud_set_me_x0_c_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lkas_hud_set_me_x0_c_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lkas_hud_repeated_beeps_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lkas_hud_repeated_beeps_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lkas_hud_repeated_beeps_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lkas_hud_set_me_x2_c_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lkas_hud_set_me_x2_c_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lkas_hud_set_me_x2_c_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lkas_hud_set_me_x38_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lkas_hud_set_me_x38_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lkas_hud_set_me_x38_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_lkas_hud_set_me_x02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_lkas_hud_set_me_x02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_lkas_hud_set_me_x02_is_in_range(uint8_t value);

/**
 * Pack message UI_SEETING.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_ui_seeting_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_ui_seeting_t *src_p,
    size_t size);

/**
 * Unpack message UI_SEETING.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_ui_seeting_unpack(
    struct new_toyotacode_ui_seeting_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_ui_seeting_units_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_ui_seeting_units_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_ui_seeting_units_is_in_range(uint8_t value);

/**
 * Pack message STEERING_LEVERS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_steering_levers_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_steering_levers_t *src_p,
    size_t size);

/**
 * Unpack message STEERING_LEVERS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_steering_levers_unpack(
    struct new_toyotacode_steering_levers_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_steering_levers_turn_signals_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_steering_levers_turn_signals_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_steering_levers_turn_signals_is_in_range(uint8_t value);

/**
 * Pack message SEATS_DOORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_seats_doors_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_seats_doors_t *src_p,
    size_t size);

/**
 * Unpack message SEATS_DOORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_seats_doors_unpack(
    struct new_toyotacode_seats_doors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_seats_doors_door_open_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_seats_doors_door_open_fl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_seats_doors_door_open_fl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_seats_doors_door_open_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_seats_doors_door_open_fr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_seats_doors_door_open_fr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_seats_doors_door_open_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_seats_doors_door_open_rr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_seats_doors_door_open_rr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_seats_doors_door_open_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_seats_doors_door_open_rl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_seats_doors_door_open_rl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_seats_doors_seatbelt_driver_unlatched_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_seats_doors_seatbelt_driver_unlatched_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_seats_doors_seatbelt_driver_unlatched_is_in_range(uint8_t value);

/**
 * Pack message LIGHT_STALK.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_light_stalk_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_light_stalk_t *src_p,
    size_t size);

/**
 * Unpack message LIGHT_STALK.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_light_stalk_unpack(
    struct new_toyotacode_light_stalk_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_light_stalk_auto_high_beam_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_light_stalk_auto_high_beam_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_light_stalk_auto_high_beam_is_in_range(uint8_t value);

/**
 * Pack message RSA1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_rsa1_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_rsa1_t *src_p,
    size_t size);

/**
 * Unpack message RSA1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_rsa1_unpack(
    struct new_toyotacode_rsa1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa1_tsgn1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa1_tsgn1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa1_tsgn1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa1_tsgngry1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa1_tsgngry1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa1_tsgngry1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa1_tsgnhlt1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa1_tsgnhlt1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa1_tsgnhlt1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa1_spdval1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa1_spdval1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa1_spdval1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa1_splsgn1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa1_splsgn1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa1_splsgn1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa1_splsgn2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa1_splsgn2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa1_splsgn2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa1_tsgn2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa1_tsgn2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa1_tsgn2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa1_tsgngry2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa1_tsgngry2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa1_tsgngry2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa1_tsgnhlt2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa1_tsgnhlt2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa1_tsgnhlt2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa1_spdval2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa1_spdval2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa1_spdval2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa1_bzrrq_p_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa1_bzrrq_p_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa1_bzrrq_p_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa1_bzrrq_a_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa1_bzrrq_a_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa1_bzrrq_a_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa1_syncid1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa1_syncid1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa1_syncid1_is_in_range(uint8_t value);

/**
 * Pack message RSA2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_rsa2_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_rsa2_t *src_p,
    size_t size);

/**
 * Unpack message RSA2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_rsa2_unpack(
    struct new_toyotacode_rsa2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa2_tsgn3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa2_tsgn3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa2_tsgn3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa2_tsgngry3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa2_tsgngry3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa2_tsgngry3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa2_tsgnhlt3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa2_tsgnhlt3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa2_tsgnhlt3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa2_splsgn3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa2_splsgn3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa2_splsgn3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa2_splsgn4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa2_splsgn4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa2_splsgn4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa2_tsgn4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa2_tsgn4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa2_tsgn4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa2_tsgngry4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa2_tsgngry4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa2_tsgngry4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa2_tsgnhlt4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa2_tsgnhlt4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa2_tsgnhlt4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa2_dpsgnreq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa2_dpsgnreq_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa2_dpsgnreq_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa2_sgnnump_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa2_sgnnump_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa2_sgnnump_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa2_sgnnuma_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa2_sgnnuma_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa2_sgnnuma_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa2_spdunt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa2_spdunt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa2_spdunt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa2_tsrwmsg_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa2_tsrwmsg_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa2_tsrwmsg_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa2_syncid2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa2_syncid2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa2_syncid2_is_in_range(uint8_t value);

/**
 * Pack message RSA3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int new_toyotacode_rsa3_pack(
    uint8_t *dst_p,
    const struct new_toyotacode_rsa3_t *src_p,
    size_t size);

/**
 * Unpack message RSA3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int new_toyotacode_rsa3_unpack(
    struct new_toyotacode_rsa3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa3_tsreqpd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa3_tsreqpd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa3_tsreqpd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa3_tsrmsw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa3_tsrmsw_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa3_tsrmsw_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa3_otsgnntm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa3_otsgnntm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa3_otsgnntm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa3_ntlvlspd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa3_ntlvlspd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa3_ntlvlspd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa3_ovspntm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa3_ovspntm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa3_ovspntm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa3_ovspvall_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa3_ovspvall_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa3_ovspvall_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa3_ovspvalm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa3_ovspvalm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa3_ovspvalm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa3_ovspvalh_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa3_ovspvalh_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa3_ovspvalh_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t new_toyotacode_rsa3_tsrspu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double new_toyotacode_rsa3_tsrspu_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool new_toyotacode_rsa3_tsrspu_is_in_range(uint8_t value);

#endif
